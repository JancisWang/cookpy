## 准备

### 有序数据：列表 `list` 与 元组 `tuple`

Python 没有其他语言的数组，用来表示有序数据的数据类型有两种，就是 `list` 和 `tuple`。

#### 创建 `list`

在 Python 中用方括号 `[]` 表示 `list`，方括号里面可以是任何东西，`int`，`float`，`bool` 还是其他的什么都无所谓，先来看看是怎么创建的：

```Python
>>> lst = []  # 定义了一个空 list lst.
>>> type(lst)
<class 'list'>
>>> bool(lst)  # 空的东西的布尔值都是 `False`
False
>>> lst = [1, 0.3, True]  # 重新定义一个"实" list lst
>>> len(lst)  # 得到 list 的长度
0
>>> lst
[1, 0.3, True]
>>> len(lst)
3
```

#### `list` 索引 与 切片

在 Python 中，有序数据中的每一个元素都具有表示次序的编号，编号是从0开始的，不允许索引超过编号的元素，可以切片。个人觉得，切片的方式是 Python 的一大特色，可以用简单的切片方式，搞定其他语言需要写好多代码才能解决的事情。

先来看看索引，直接使用 `[i]`，索引返回的是一个元素。得到索引使用 `list.index(x)`。

代码示例：

```Python
>>> lst[0]
1
>>> lst[1]
0.3
>>> lst[-1]  # 索引时，可以是负数，表示从尾到头
True
>>> lst[-2]
0.3
>>> lst.index(1)  # 得到的是第一个元素值为1的索引
```

然后是切片，和索引不同，切片返回的是一个新的 `list`。

一个完整的切片表达式是这样的：

```Python
lst[start:end:step]
```

`step` 默认是1，可以省略。切片的时候，第一个 `:` 不可省略。

切片代码示例：

```Python
>>> num_lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> num_lst[:]  # 截取整个list
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> num_lst[:5]  # 截取前5个
[1, 2, 3, 4, 5]
>>> num_lst[-4:]  # 截取后4个
[7, 8, 9, 10]
>>> num_lst[2:6]  # 截取第三个到第6个
[3, 4, 5, 6]
>>> num_lst[-6:-2]  # 截取倒数第6个到倒数第三个
[5, 6, 7, 8]
>>> num_lst[-2:-6:-1]  # 截取倒数第二个到倒数第五个
[9, 8, 7, 6]
>>> num_lst[::2]  # 截取编号为偶数的
[1, 3, 5, 7, 9]
>>> num_lst[1::2]  # 截取编号为奇数的
[2, 4, 6, 8, 10]
>>> num_lst[::3] # 截取编号为0, 3, 6, 9的
[1, 4, 7, 10]
>>> num_lst[::-1]  # 截取倒数第一个到第一个（反转整个 list）
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

#### 对 `list` 的操作

对 `list` 操作，包括添加元素，合并两个 `list`，删除元素，反转和排序。操作是在原始 `list` 上产生的，而非生成一个新的 `list`。

**添加**元素最常用的是 `list.append(x)`，用来在原始 `list` 最后添加一个元素。其次是 `list.insert(i, x)` ，官方文档：

> list.insert(i, x)
>	> Insert an item at a given position. The first argument is the index of the element before which to insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to a.append(x).

**合并** `list`，一般使用的是 `list.extend(L)`，有些时候可能会见得到这样合并两个 `list` 的方式：

```Python
list3 = list1 + list2
```

啊，这样合并 `list` 得到的是一个新的 `list` 而非在原始的 `list` 上操作（而且我不是很推荐这样做，很多库使用类似 `list` 的数据结构时，这样做都是两个 `list` 里面的元素互相相加。）

**删除** `list` 的元素一般用 `list.pop([i])` 删除 `list` 的编号为 `i` 的元素。这里的 `[i]` 表示的是 `i` 是可以省略的，默认的 `i` 是最后一位。另外一种方式是，当你知道 `list` 元素时，可以使用 `list.remove(x)` 删除第一个 `x` 元素。

**反转** `list` 使用 `list.reverse()`

**排序** `list` 使用 `list.sort()`，默认是从小到大，如果要从大到小可以 `list.sort(reverse=True)`

**更改 `list` 元素** 只需要索引到元素，可以使用切片的方式索引多个元素，再重新赋值就行。

代码示例：

```Python
>>> lst = [1,2,3,4,5]
>>> lst.append(6)
>>> lst
[1, 2, 3, 4, 5, 6]
>>> lst.insert(0,7)
>>> lst
[7, 1, 2, 3, 4, 5, 6]
>>> lst.sort()
>>> lst
[1, 2, 3, 4, 5, 6, 7]
>>> lst.extend(lst)
>>> lst
[1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7]
>>> lst.append([1, 2, 3])
>>> lst
[1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, [1, 2, 3]]
>>> lst.pop()
[1, 2, 3]
>>> lst
[1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7]
>>> lst.remove(3)
>>> lst
[1, 2, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7]
>>> lst.sort(reverse=True)
>>> lst
[7, 7, 6, 6, 5, 5, 4, 4, 3, 2, 2, 1, 1]
>>> lst.reverse()
>>> lst
[1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7]
# 更改
>>> lst[0] = 0
>>> lst
[0, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7]
>>> lst[0:5:2] = [10, 10, 10]
>>> lst
[10, 1, 10, 2, 10, 4, 4, 5, 5, 6, 6, 7, 7]
```

#### 不可更改的 `list` -- 元组 `tuple`

`[]` 创建的是 `list`，`()` 创建的就是 `tuple`，需要注意的是，如果生成的 tuple 中只有一个元素，需要在后面加一个 ','。

代码示例：

```Python
>>> tpl = (1, 2, True, [1, 2, 3], [], (1, 2))
>>> tpl
(1, 2, True, [1, 2, 3], [], (1, 2))
>>> tpl2 = (1)  # 此时()表示的是运算优先度，而不是生成元组
>>> tpl2
1
>>> tpl3 = (1,)
>>> tpl3
(1,)
```

`tuple` 的索引与切片与 `list` 没有什么区别，但 `tuple` 是不能更改的，也就是说，之前的 `list` 的一切操作，合并啊，添加啊，删除啊什么的，对 `tuple` 来说，都是不存在的。当然，组合两个 `tuple` 可以使用：

```Python
tuple3 = tuple1 + tuple2
```

因为，这是生存一个新的 `tuple`。

那 `tuple` 用在什么地方呢？`list` 与 `tuple` 都可以用来表示有序数据，但是 `list` 可以更改，有些时候，这个更改可能会坏事，这时使用 `tuple` 的话，可以避免这种情况导致的 bug。

#### `list` 与 `tuple` 互相转换

`list` 与 `tuple` 互相转换非常简单：

```Python
list(tuple)  # tuple to list
tuple(list)  # list to tuple
```

实际上，`list()` 是一个用来创建 `list` 的东西，括号内如果什么都不填，就相当于 `[]`，同样 `tuple` 也是这样的。

#### 注意⚠️

使用 `list` 以及 `tuple` 的时候，有一些地方需要注意，比如当你想得到一个 `list` 的拷贝时，不能简单的直接用 `b = a` 这样的形式，这样得到的新 `list` 和老的其实是同一个东西，新的改变了，老的也会变。有两种简单的办法可以得到新的拷贝，一种是 `list.copy()`，一种是 `list[:]`。

代码示例：

```Python
# 正确的拷贝方式
>>> a = [0, 5, 1, 7]
>>> b = a[:]
>>> c = a.copy()  # b 和 c 都是 a 的拷贝，与 a 只是数值上相等
>>> a
[0, 5, 1, 7]
>>> b
[0, 5, 1, 7]
>>> c
[0, 5, 1, 7]
>>> id(a)  # 用 id(...) 查看是否是同一个东西
4386077576
>>> id(b)
4382838536
>>> id(c)
4386036680
# 错误的拷贝方式
>>> a = [3, 1, 5, 4]
>>> a
[3, 1, 5, 4]
>>> b = a  # 此时得到的 b 和 a 是同一个东西
>>> b
[3, 1, 5, 4]
>>> b[0] = 0  # 因为是同一个东西，b 更改时，a 也会一起更改
>>> b
[0, 1, 5, 4]
>>> a
[0, 1, 5, 4]
>>> id(a)
4386036680
>>> id(b)
4386036680
```


### 


